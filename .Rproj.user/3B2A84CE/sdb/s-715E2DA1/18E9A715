{
    "contents" : "---\ntitle: \"dataMunging\"\nauthor: \"Michael Khan\"\ndate: \"4 January 2016\"\noutput: html_document\n---\n\nThis is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.\n\nWhen you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:\n\nSet working directory\nChange this path as needed to run\n```{r}\nsetwd(\"~/Dropbox/DataAnalytics/RugbyWC2015/code\")\n```\n\n\nNecessary imports\n```{r}\nlibrary(reshape2)\nlibrary(cluster)\nlibrary(ggplot2)\n```\n\nImport Data\n```{r}\ndata <- read.csv('../data/rwc2015.csv', header = TRUE)\nplayerPositions <- read.csv('../data/playerPositions.csv', header = TRUE)\n```\n\n\nQuick exploration of the data\n```{r}\ndim(data)\nnames(data)\n```\nFrom this we can see that there are 4088 observations with 4 variables each: player_name, country, metric, value\n\n\nNow lets look further into the data\n```{r}\nsummary(data)\n```\nFrom this summary of the fields we can start to see how the data is organised in the file.\nIt looks like each player is represented by multiple rows of data, with the metric field showing which of the metrics is beeing show in this row.\n```{r}\nunique(data$metric)\n```\nAs we can see from the above command there are 10 different metrics shown in this data.\n\n\nAs I continue with my analysis I would prefer to transform this data so that each metric is a variable and each row is a player.\nFor this task I will use the reshape2 package imported above\n\n```{r}\nnew_data <- dcast(data, player_name + country ~ metric)\nnew_data_NAs <- new_data\n```\n\nHere is an short extract of what the data look like now\n```{r}\nhead(new_data)\n```\nAs we can see from the above extract NA was inserted where the values did not exist for a given player and metric. It looks like the NAs signify when a player has 0 of a metric, altough I am not 100% sure for this exercise I will replace NAs with 0\n```{r}\nnew_data[is.na(new_data)] <- 0\n```\nThe summary of the 10 different metrics' is now more true to reality\n```{r}\nsummary(new_data)\n```\n\n\nI'm going to divide all the metrics by the number of games played by each player to remove bias of the number of games played by each player.\n```{r}\ncolumnsToDivide <- c(3,4,5,6,7,9,10,11,12)\nfor(i in columnsToDivide) {\n  new_data[ ,i] = new_data[ ,i] / new_data$matches\n} \n```\n\n\nFinding the leader in each category \n```{r}\nmax_carries <- new_data[new_data$carries == max(new_data$carries),]\nmax_cogl <- new_data[new_data$carries_over_gain_line == max(new_data$carries_over_gain_line),]\nmax_cb <- new_data[new_data$clean_breaks == max(new_data$clean_breaks),]\nmax_los <- new_data[new_data$lineout_steals == max(new_data$lineout_steals),]\nmax_low <- new_data[new_data$lineouts_won == max(new_data$lineouts_won),]\nmax_mm <- new_data[new_data$metres_made == max(new_data$metres_made),]\nmax_om <- new_data[new_data$offloads_made == max(new_data$offloads_made),]\nmax_tries <- new_data[new_data$tries == max(new_data$tries),]\nmax_tow <- new_data[new_data$turnovers_won == max(new_data$turnovers_won),]\n```\n\n\nI'm going to try to use K-means clustering to see if we can group players by possitions by using just the 10 fields provided in the data. With K-means you have to specify the number of center to use for clustering I'm going to start with 9, one for each position: prop, hooker, lock, back row, scrum half, fly half, center, wing and full back \n```{r}\n\n\nset.seed(1)\nkmeansIn <- data.matrix(new_data[, -c(1,2,8)])\nkmeansRes <- kmeans(kmeansIn, centers = 3)\n```\n\nadding a new column to the data to hold the number of the cluster it was assigned to.\n```{r}\nnew_data$cluster <- kmeansRes$cluster\n```\n\n\nMerging the two different data sources to check the results of clustering on \n```{r}\nmerged <- merge(x = new_data, y = playerPositions, by.x = 'player_name', by.y = 'Player.name')\nmerged_left <- merge(x = new_data, y = playerPositions, by.x = 'player_name', by.y = 'Player.name', all.x = TRUE)\nmerged_right <- merge(x = new_data, y = playerPositions, by.x = 'player_name', by.y = 'Player.name', all.y = TRUE)\n\nmissing_left <- merged_left[is.na(merged_left$Pos), ]\nmissing_right <- merged_right[is.na(merged_right$country), ]\n```\nonly 535 of 620 were matched. This issue seems to be caused mostly by small discrepancies in the names between the two data sources e.g. Apisalome Ratuniyarawa / Api Ratuniyarewa. For this exercise its ok to disregard the 87 missmatches, for other more important problems we could use a fuzzy string matching algorithm like the Levenshtein distance algorithm to match the strings that don't match exactly.\n\n```{r}\nkmeansRes$size\n```\n\nLets look at a table of position vs cluster\n```{r}\ntable(merged$cluster, merged$Pos)\n```\n\n\nSplit the data into 3 dataframes one for each cluster\n```{r}\nclust3 <- merged[merged$cluster == 3, ]\nclust1 <- merged[merged$cluster == 1, ]\nclust2 <- merged[merged$cluster == 2, ]\nsummary(clust1$Pos)\n\n```\n\n\n***Cluster Plot\nCreate silhouette plot\n```{r}\ngraphColors = c('red', 'green', 'blue')\ndissE <- daisy(kmeansIn)\ndE2 <- dissE^2\nsk2 <- silhouette(kmeansRes$cl, dE2)\nplot(sk2, col=graphColors)\n```\n\n\n\n***Exploratory Graphs\n\nComparing tries scored by cluster\n```{r}\nboxplot(merged$tries ~ merged$cluster, varwidth = TRUE, col=graphColors, xlab='Cluster', ylab='Tries scored per game', main='Tries scored per game cluster comparison')\nggplot(merged, aes(merged$tries, fill = as.factor(merged$cluster))) + geom_density(alpha = 0.2)\n```\n\n\nComparing meters made by cluster\n```{r}\nboxplot(merged$metres_made ~ merged$cluster, varwidth = TRUE, col=graphColors, xlab='Cluster', ylab='Meters made per game', main='Meters made cluster comparison')\n#ggplot(merged, aes(x=as.factor(merged$cluster), y=metres_made, fill=as.factor(merged$cluster))) + geom_boxplot() + scale_fill_discrete(name = 'Clusters')\nggplot(merged, aes(metres_made, fill = as.factor(merged$cluster))) + geom_density(alpha = 0.2) + scale_fill_discrete(name = 'Clusters')\n```\n\nComparing turn overs by cluster\n```{r}\nboxplot(merged$turnovers_won ~ merged$cluster, varwidth = TRUE, col=graphColors, xlab='Cluster', ylab='Meters made per game', main='Meters made cluster comparison')\nggplot(merged, aes(turnovers_won, fill = as.factor(merged$cluster))) + geom_density(alpha = 0.2) + scale_fill_discrete(name = 'Clusters')\n```\n\nComparing clean breaks by cluster\n```{r}\nboxplot(merged$clean_breaks ~ merged$cluster, varwidth = TRUE, col=graphColors, xlab='Cluster', ylab='Clean breaks made per game', main='Clean breaks made cluster comparison')\nggplot(merged, aes(clean_breaks, fill = as.factor(merged$cluster))) + geom_density(alpha = 0.2) + scale_fill_discrete(name = 'Clusters')\n```\n\nComparing carries over gain line (cogl) by cluster\n```{r}\nboxplot(merged$carries_over_gain_line ~ merged$cluster, varwidth = TRUE, col=graphColors, xlab='Cluster', ylab='Carries over gain line per game', main='Carries over gain line cluster comparison')\nggplot(merged, aes(carries_over_gain_line, fill = as.factor(merged$cluster))) + geom_density(alpha = 0.2) + scale_fill_discrete(name = 'Clusters')\n```",
    "created" : 1452115023192.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2747743855",
    "id" : "18E9A715",
    "lastKnownWriteTime" : 1452291902,
    "path" : "~/Dropbox/DataAnalytics/RugbyWC2015/code/dataMunging.Rmd",
    "project_path" : "code/dataMunging.Rmd",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_markdown"
}